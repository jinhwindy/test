/**
 * 变量提升
 *  =>当栈内存（作用域）形成，JS代码自上而下执行之前，
 *  浏览器首先会把所有带‘var /function’关键字的进行提前'声明'或者'定义'。
 *  这种预先处理机制称为‘变量提升’
 * 
 * =>声明（declare）：var a (默认值undefined)
 * =>定义（defined）：a=12（定义其实就是赋值操作）
 * 
 * 变量提升阶段发生在：栈内存形成之后，代码执行之前
 * 
 * [变量提升阶段]
 * =>带 var 的之声明为定义
 * =>带 function 的声明和赋值都完成了
 * 
 * => 变量提升只发生在当前作用域（例如：开始加载页面的时候值对全局作用域下的
 * 进行提升，因此此时函数中存储的只是字符串而已）
 * => 在全局作用域下声明的函数或者变量是‘全局变量’，同理，在私有作用域下声明
 * 的变量是‘私有变量’ 【带var/function的才是声明】
 * 
 * =>浏览器很懒，做过的事情不会重复执行重复执行第二遍，也就是，当代码执行遇到
 * 创建函数这部分后，直接跳过即可（因为在提升阶段就已经完成函数的赋值操作了）
 * 
 * 私有作用域形成后，也不是立即代码执行，而是先进行变量提升
 * （变量提升前，先形参赋值）
 * 在ES3/ES5语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他
 * 大括号不会形成栈内存
 */
console.log(a);//=>undefined
var a=12;